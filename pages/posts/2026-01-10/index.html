<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="post-status" content="inactive" />
    <title>Stack Operations and Function Invocation</title>
    <link rel="stylesheet" href="../../../assets/style.min.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <link
      rel="icon"
      href="../../../assets/favicon/duck.jpg"
      type="image/jpeg"
    />
    <link rel="apple-touch-icon" href="../../../assets/favicon/duck.jpg" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
  </head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/x86asm.min.js"></script>

  <body>
    <main class="container post-page" data-category="">
      <a class="back-link" id="backLink" href="#">← All Posts</a>
      <header class="post-header">
        <h1 class="post-title">Stack Operations and Function Invocation</h1>
        <div class="post-meta">2026-01-10</div>
      </header>
      <article class="post-content">
        <section id="fore-word">
          <p>
            <span class="highlight">Overview:</span> In the previous post on
            <a href="../2026-01-05/index.html" class="highlight"
              >Data Management & String Instructions</a
            >. We explored how CPU handles data transfer between registers and
            memory. We also saw that, from the CPU’s perspective, a “string” is
            simply a sequence of bytes terminated by a NULL byte. In this post,
            we will explore how the CPU manages the stack structure, how
            function calls are performed, and how calling conventions define the
            interaction between caller and callee.
          </p>
        </section>
        <section id="outline">
          <ul>
            <li>
              <a class="highlight" href="#stack-operations">Stack Operations</a>
            </li>
            <li>
              <a class="highlight" href="#function-invocation"
                >Function Invocation</a
              >
            </li>
            <li>
              <a class="highlight" href="#calling-convention"
                >Calling Convention</a
              >
            </li>
            <li>
              <a href="#sumup" class="highlight">Sumup</a>
            </li>
          </ul>
        </section>
        <!-- Stack Operations  -->
        <section>
          <p>
            <span id="stack-operations" class="title-highlight"
              >Stack Operations</span
            >
          </p>
          <p>
            The stack is a
            <span class="inline-highlight">LIFO</span>
            (last-in-first-out) structure used for local variables, saved state,
            and function calls. <br />
            From the CPU’s perspective, the stack is a contiguous memory region
            pointed to by <span class="inline-highlight">ESP</span> , and it
            grows downward.
          </p>
          <div class="image-container-500-500 image-container-center">
            <img src="./img/stack.gif" class="zoomImage" alt="stack" />
          </div>
          <p>
            To perform stack operations, the CPU relies primarily on two
            registers, <span class="inline-highlight">ESP</span> and
            <span class="inline-highlight">EBP</span>, along with the
            instructions <span class="inline-highlight">PUSH</span> and
            <span class="inline-highlight">POP</span>. But what exactly are the
            roles of these registers, and how do these instructions manage data
            within the stack structure?
          </p>
          <ul>
            <li>
              <span class="inline-highlight">PUSH</span>: decreases
              <span class="inline-highlight">ESP</span>, then writes the value
              to <span class="inline-highlight">[ESP]</span>
            </li>
            <li>
              <span class="inline-highlight">POP</span>: reads [ESP], then
              increases <span class="inline-highlight">ESP</span>
            </li>
          </ul>
          <p>See the example below:</p>
          <pre
            class="code-block"
          ><code class="language-x86asm">; initial ESP = 0xb20000
01: B8 AA AA AA AA mov eax, 0AAAAAAAAh
02: BB BB BB BB BB mov ebx, 0BBBBBBBBh
03: B9 CC CC CC CC mov ecx, 0CCCCCCCCh
04: BA DD DD DD DD mov edx, 0DDDDDDDDh
05: 50             push eax           ; address 0xb1fffc will contain the value 0xAAAAAAAA and ESP
                                      ; will be 0xb1fffc (=0xb20000-4)
06: 53             push ebx           ; address 0xb1fff8 will contain the value 0xBBBBBBBB and ESP
                                      ; will be 0xb1fff8 (=0xb1fffc-4)
07: 5E             pop esi            ; ESI will contain the value 0xBBBBBBBB and ESP will be 0xb1fffc
                                      ; (=0xb1fff8+4)
08: 5F             pop edi            ; EDI will contain the value 0xAAAAAAAA and ESP will be 0xb20000
                                      ; (=0xb1fffc+4)</code></pre>
          <div class="image-container">
            <img
              src="./img/stack-layout.png"
              alt="stack layout"
              class="zoomImage"
            />
          </div>
          <p>
            As the image above,
            <span class="inline-highlight">the stack pointer (ESP)</span> is
            modified whenever <span class="inline-highlight">PUSH/POP</span> but
            actually it also
            <span class="inline-highlight">can be modified</span> by
            <span class="inline-highlight">ADD/SUB</span>. <br />
            <span class="inline-highlight">ESP</span> is just a normal register,
            so if we <span class="inline-highlight">sub esp, 0x20</span>, we
            just make space for 32 bytes on the stack for local variables.
            <span class="inline-highlight">add esp, 8</span> clear 2 arg with 4
            bytes each.
            <br />
            <br />
          </p>
          <p>
            That is how the stack works from the CPU’s perspective.
            <span class="title-highlight" id="function-invocation"></span> So
            how about function? While high-level programming languages have the
            concept of functions that can be called and returned. From CPU
            perspective functions are implemented through the stack data
            strucuture. Example as following:
          </p>
          <pre class="code-block"><code class="language-c"
              >// in C language we can see "sum" is the function which makes sum of first and second argument
...
int sum(int a, int b){
  return a+b;
}
int main(){
  int c = sum(7,8);
  return c;
}</code></pre>
          <pre class="code-block"><code class="language-x86asm"
              >; this is CPU perspective
sum:
    push ebp
    mov  ebp, esp         ; init ebp to store address at bottom of stack 
    mov  eax, [ebp+8]     ; store a in EAX
    add  eax, [ebp+12]    ; make the arithmetic instruction add EAX + [EBP+12] which is EAX = 7+8
    pop  ebp
    ret
; int main(){ int c = sum(a,b); return c; }
main:
    push ebp
    mov  ebp, esp         ; 
    sub  esp, 4           ; reserve space for local c (at [ebp-4])
    push 8                ; b
    push 7                ; a
    call sum
    add  esp, 8           ; cdecl: caller cleans 2 args
    mov  [ebp-4], eax     ; c = return value
    mov  eax, [ebp-4]     ; return c in eax
    mov  esp, ebp
    pop  ebp
    ret
}</code></pre>
          <p>
            Before going into details we can see the 2 new instructions which
            are
            <span class="inline-highlight">CALL/RET</span>
          </p>
          <p>
            <span class="inline-highlight"> CALL instruction</span>
            performs two operations:
          </p>
          <ul>
            <li>
              Push the return address - this is the address of next instruction
            </li>
            <li>
              Change EIP to address of "sum" function then calls the target and
              begins execution
            </li>
          </ul>
          <pre class="code-block"><code class="language-x86asm"
>0x00401000  call sum
0x00401005  mov ecx, eax
0x0040100D sum: 
.....
----------
; CPU actually does 
push return_address   ; return_address is the address of next instruction, which is 00401005
jump target           ; target is the address of sum, which is 0x0040100D
          </code></pre>
          <p>
            <span class="inline-highlight"> RET instruction</span>
            performs:
          </p>
          <ul>
            <li>
              Pop the return address into EIP. Then jumps to that address and
              begins execution
              <pre class="code-block"><code class="language-x86asm"
>0x00401000  call sum
0x00401005  mov ecx, eax
0x0040100D sum: 
.....
0x0040200D ret
----------
; CPU actually does 
pop eip   ; pop and set EIP to return_address 
          </code></pre>
            </li>

            <li>
              We may seen some instruction like
              <span class="inline-highlight">ret 8</span>. It actually performs
              2 task.
              <pre class="code-block"><code class="language-x86asm"
>pop eip 
add esp, 8 ; add 4 to esp as default, then add more 8 to esp</code></pre>
            </li>
          </ul>
          <p>
            With this understanding, we can now explore how different calling
            conventions formalize these rules.
          </p>
          <br />
          <p>
            <span id="calling-convention" class="title-highlight"
              >Calling convention</span
            >
            is a set of rules that define how function calls work at the machine
            level.
          </p>
          <p>
            And before going into details. We need to know some purpose that are
            shown in the table
          </p>
          <ul>
            <li>
              <span class="inline-highlight">Agrument</span>: Where to pass
              parameter (stack or register)
            </li>
            <li>
              <span class="inline-highlight">Order</span>: In what order are
              agruments pushed onto the stack
            </li>
            <li>
              <span class="inline-highlight">Stack Clean</span>: Who cleans up
              the stack after the call (<a href="#caller" class="highlight"
                >caller</a
              >
              or <a href="#callee" class="highlight">callee</a>)
            </li>
            <li>
              <span class="inline-highlight">Return</span>: In which register is
              return value stored
            </li>
            <li>
              <span class="inline-highlight">Callee-saved registers</span>
              : Which registers must the callee preserve (i.e., if used, they
              must be saved and restored)?
            </li>
            <li>
              <span class="inline-highlight">Varargs</span>: Does it support
              variadic functions such as printf?
            </li>
          </ul>
          <hr />
          <p>
            <span id="caller" class="inline-highlight">Calleer</span>-Refers to
            a function that call to another function
          </p>
          <p>
            <span id="callee" class="inline-highlight">Callee</span>-Function
            being called
          </p>
          <pre
            class="code-block"
          ><code class="language-c">int sum(int a, int b); // sum is the callee
int main() {     // main calls sum -> main is the caller
    int c = sum(1, 2);
    return 0;
}</code></pre>
          <pre class="code-block">
===============================
x86 (32-bit) Calling Conventions
===============================

+------------+---------------------------+------------------+--------------+--------+-------------------------+---------+
| Convention | Arguments                 | Order            | Stack Clean  | Return | Callee-Saved Registers  | Varargs |
+------------+---------------------------+------------------+--------------+--------+-------------------------+---------+
| cdecl      | Stack                     | Right-to-left    | Caller       | EAX    | EBX, ESI, EDI, EBP      | Yes     |
| stdcall    | Stack                     | Right-to-left    | Callee       | EAX    | EBX, ESI, EDI, EBP      | No      |
| fastcall   | ECX, EDX + Stack          | Regs then stack  | Callee (MS)  | EAX    | EBX, ESI, EDI, EBP      | Limited |
| thiscall   | ECX (this) + Stack        | Right-to-left    | Caller*      | EAX    | EBX, ESI, EDI, EBP      | Limited |
+------------+---------------------------+------------------+--------------+--------+-------------------------+---------+

(* typical MSVC behavior)

================================
x86-64 (64-bit) Calling Conventions
================================

+----------------------+-----------------------------+--------------+--------+---------------------------+---------+
| ABI                  | Integer Arguments           | Stack Clean  | Return | Callee-Saved Registers    | Varargs |
+----------------------+-----------------------------+--------------+--------+---------------------------+---------+
| System V AMD64       | RDI, RSI, RDX, RCX, R8, R9  | Caller       | RAX    | RBX, RBP, R12–R15         | Yes     |
| Microsoft x64        | RCX, RDX, R8, R9            | Caller       | RAX    | RBX, RBP, RSI, RDI, R12–R15| Yes    |
+----------------------+-----------------------------+--------------+--------+---------------------------+---------+

Microsoft x64 requires 32-byte shadow space allocated by the caller.
System V requires 16-byte stack alignment before CALL.
</pre
          >
          <p>
            The content below is a
            <span class="inline-highlight"
              >series of examples of calling conventions</span
            >
            in x86 and x86-64.
          </p>
          <p class="title-highlight">Starting with x86 (32-bit)</p>
          <p>
            Example of the basic <span class="inline-highlight">cdecl</span>,
            its code in C either ASM
          </p>
          <!-- <pre class="code-block"><code class="language-c"></code></pre> -->
          <pre class="code-block"><code class="language-c">// example in C
int add(int a, int b) {
    return a + b;
}
int main(){int x = add(2,3); return x}</code></pre>
          <pre class="code-block"><code class="language-x86asm"
>add:               ; add is the callee 
push ebp
mov ebp, esp
mov eax, [ebp+8]
add eax, [ebp+12]
pop ebp
ret                 ; just pop eip 

main:
    push 3          ; order right-to-left
    push 2
    call add        ; main is caller, call to add function 
    add esp, 8      ; caller-main has to clean the stack by modifying esp
</code></pre>
          <p>Example of <span class="inline-highlight">sdtcall</span></p>
          <pre
            class="code-block"
          ><code class="language-c">int __stdcall add(int a, int b)</code></pre>
          <pre class="code-block"><code class="language-x86asm"
>add:               ; add is the callee 
push ebp
mov ebp, esp
mov eax, [ebp+8]
add eax, [ebp+12]
pop ebp
ret 8              ; callee clean the stack by modifying esp = esp + 4 + 8

main:
    push 3          ; order right-to-left
    push 2
    call add        ; main is caller, call to add function 
</code></pre>
          <p>Example of <span class="inline-highlight">fastcall</span></p>
          <pre
            class="code-block"
          ><code class="language-c">int __fastcall add(int a, int b, int c)</code></pre>
          <pre class="code-block"><code class="language-x86asm"
>add:               ; add is the callee 
push ebp
mov ebp, esp
mov eax, ecx
add eax, edx
pop ebp
ret 4              ; callee clean the stack by modifying esp = esp + 4 + 4 (just 1 agrument pushed into stack)

main:
    mov ecx, 1    ; first two arguments assign to registers (ECX, EDX)
    mov edx, 2
    push 3         ; third argument assign to stack
    call add       ; main is caller, call to add function 
</code></pre>
          <p class="title-highlight">With x86-64 (64-bit)</p>
          <p>
            Because x86-64 has more registers than x86, there for first four
            arguments will be stored in four register, which is RCX, RDX, R8, R9
          </p>
          <p>
            Also, Microsoft x64 requires 32-byte shadow space allocated by the
            caller. 32 bytes shadow space = 4 qword slots for RCX, RDX, R8, R9.
          </p>
          <pre class="code-block"><code class="language-x86asm"
>sum:
    mov rax, rcx
    add rax, rdx
    add rax, r8
    add rax, r9
    add rax, qword ptr [rsp+40]  ; because return address is pushed into stack 
    ret
main:
    sub rsp, 40                 ; 32-byte shadow space + align
    mov rcx, 1                  ; arg1
    mov rdx, 2                  ; arg2
    mov r8, 4                   ; arg3
    mov r9, 5                   ; arg4
    mov qword ptr [rsp+32], 3   ; arg5 (get from stack, placed after shadow space)
    call sum
    add rsp, 40
    ret
</code></pre>
          <p>The picture below shown the stack layout</p>
          <div class="image-container">
            <img src="./img/call sum.png" alt="stay-layout" class="zoomImage" />
          </div>
          <!-- sumup -->
          <section>
            <p class="title-highlight" id="sumup">Sumup</p>
            <p>
              In this post, we explored how the stack works at the CPU level and
              how function calls are implemented using CALL and RET. <br />
              We saw how arguments are passed, how return values are stored, and
              how calling conventions define the contract between caller and
              callee in both x86 and x86-64. <br />
              In the next post, we will explore how the if/else, switch case
              structure are implemented in machine-level, also how the CPU
              handle flow in ASM.
            </p>
          </section>
        </section>
      </article>
      <div id="modal" class="modal">
        <span id="closeModal" class="close-btn">&times;</span>
      </div>
    </main>
    <script src="../../../assets/app.obf.js" defer></script>
  </body>
</html>
