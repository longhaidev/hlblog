<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="post-status" content="active" />
    <title>Control Flow</title>
    <link rel="stylesheet" href="../../../assets/style.min.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="icon"
      href="../../../assets/favicon/duck.jpg"
      type="image/jpeg"
    />
    <link rel="apple-touch-icon" href="../../../assets/favicon/duck.jpg" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
  </head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <body>
    <main class="container post-page" data-category="">
      <a class="back-link" id="backLink" href="#">← All Posts</a>
      <header class="post-header">
        <h1 class="post-title">Control Flow</h1>
        <div class="post-meta">2026-01-12</div>
      </header>
      <article class="post-content">
        <!-- <section>
            <p>
              <span id="control-flow" class="title-highlight"
                >Control Flow</span
              >
            </p>
            <p>
              Similar to function in high-level construct. In this section we
              will explore how does the CPU implement high-level constructs like
              <span class="inline-highlight">if/else</span>,
              <span class="inline-highlight">switch/case</span>, and
              <span class="inline-highlight">while/for loops</span> in
              machine-level. And also the
              <span class="inline-highlight">EFLAGS</span> register is mentioned
              in this section.
            </p>
            <p>
              Let's begin with a list, which summarizes the common flags in
              <span class="inline-highlight"> EFLAGS</span>
            </p>
            <ul>
              <li>
                <span class="inline-highlight">ZF</span> (Zero flag) — If zero
                or not zero.
              </li>
              <li>
                <span class="inline-highlight">SF</span> (Sign flag) — If
                negative or positive. By checking the highest bit.
              </li>
              <li>
                <span class="inline-highlight">CF</span> (Carry flag) — If
                overflow if calculate unsigned number. It applies to
                <a class="highlight" href="#signed-unsigned-num"
                  >unsigned numbers</a
                >.
              </li>
              <li>
                OF (Overflow flag) — If overflow if calculate signed number. It
                applies to
                <a class="highlight" href="#signed-unsigned-num"
                  >signed numbers</a
                >.
              </li>
            </ul>
            <p>
              <span id="signed-unsigned-num" class="inline-highlight"
                >Signed and Unsigned number, what is that?</span
              >
            </p>
            <p>
              CPU does not know if there is a
              <span class="inline-highlight">negative</span> number or
              <span class="inline-highlight">positive</span> number. It’s all
              based on
              <span class="inline-highlight">bits</span>
            </p>
            <p>
              So the <span class="inline-highlight">Signed number</span>, which
              has a positive or negative sign. It coulde be 1, or
              -1,...Determine by checking the highest bit. For example:
            </p>
            <pre class="code-block"><code class="language-x86asm">01111111 = 127
10000000 = -128
11111111 = -1</code></pre>
            <p>
              How about the
              <span class="inline-highlight">Unsigned number</span>, which does
              not has the positive or negative sign. For example:
            </p>
            <pre class="code-block"><code class="language-x86asm">00000000 = 0
00000001 = 1
11111111 = 255</code></pre>
            <p>
              Another example: CPU is reading a number, which is
              <span class="inline-highlight">11111111</span>
            </p>
            <pre
              class="code-block"
            ><code class="language-x86asm">11111111 = 255 -> IF the CPU mark this number as a UNSIGNED 
11111111 = -1 -> IF the CPU mark this number as a SIGNED </code></pre>
            <p>
              That some points about Signed and Unsigned number.
              <br />
              <br />
            </p>
            <p>
              Now we dive deeper in Control flow. So the flag in
              <span class="inline-highlight">EFLAG</span> would be set by the
              result of the
              <span class="inline-highlight">arithmetic instruction</span>. And
              the <span class="inline-highlight">J[cc]</span> instruction where
              the <span class="inline-highlight">"cc"</span> is
              <span class="inline-highlight">condition code</span> changes the
              controls flow depending on these flag. See table of the most
              common condition codes and example below:
            </p>
            <div class="image-container">
              <img
                src="./img/condition-codes.png"
                alt="condition codes"
                class="zoomImage"
              />
            </div>
            <pre
              class="code-block"
            ><code class="language-x86asm">01: mov esi, [ebp+8] 
02: mov edx, [esi]
03: test edx, edx        ; the TEST instruction performs as same as the AND instruction. Set the flag status  
04: jz short loc_4E31F9  ; after line 3, the ZF flag in EFLAGS regiser is set.
; ZF = 1 if EDX ==0 and the instruction in line 4 J/Z write in jz (jump if zero) will be executed
; ZF = 0 if EDX !=0</code></pre>
            <p>
              Based on this, we can understand how an
              <span class="inline-highlight">if/else construct</span> is
              implemented at the machine-code level.
            </p>
            <pre
              class="code-block"
            ><code class="language-x86asm">01: mov esi, [ebp+8]
02: mov edx, [esi]
03: test edx, edx                               ; the "if" condition then set the ZF flag *ESI == 0?...:return
04: jz short loc_4E31F9
05: mov ecx, offset _FsRtlFastMutexLookasideList
06: call _ExFreeToNPagedLookasideList@8         ; call function
07: and dword ptr [esi], 0                      ; *esi = 0 
08: lea eax, [esi+4]
09: push eax
10: call _FsRtlUninitializeBaseMcb@4
11: loc_4E31F9:                                 ; instructions if condition is met
12: pop esi                                     ; return 
13: pop ebp                        
14: retn 4                                      ; retn 4 means pop the return address then add 4 to esp 
15: _FsRtlUninitializeLargeMcb@4 endp</code></pre>
            <p>
              So do the
              <span class="inline-highlight">switch/case construct</span> is a
              sequence of if/else statements
            </p>
            <pre class="code-block"><code class="language-x86asm">01: push ebp
02: mov ebp, esp        
03: mov eax, [ebp+8]    ; EAX = *(EBP+8)
04: sub eax, 41h        ; EAX - 0x41 == 0 ? ZF = 1 : ZF = 0 (check if EAX = "A")
05: jz short loc_caseA
06: dec eax
07: jz short loc_caseB
08: dec eax
09: jz short loc_caseC
10: mov al, 5Ah
11: movzx eax, al
12: pop ebp
13: retn
14: loc_caseC:          ; same with caseA
15: mov al, 43h
16: movzx eax, al
17: pop ebp
18: retn
19: loc_caseB:          ; same with caseA
20: mov al, 42h
21: movzx eax, al
22: pop ebp
23: retn
24: loc_caseA:          
25: mov al, 41h
26: movzx eax, al   ; return "A" character
27: pop ebp
28: retn</code></pre>
            <p>
              From this pattern, we can see how high-level constructs map
              directly to conditional jumps. Now next is the
              <span class="inline-highlight">loop construct</span>. In
              machine-code loops are implemented using the combination of
              <span class="inline-highlight">JCC</span> and
              <span class="inline-highlight">JMP</span>
            </p>
            <p>
              In other words. We can imagine that they are implemented by using
              <span class="inline-highlight">if/else</span> and
              <span class="inline-highlight">goto</span>
            </p>
            <pre
              class="code-block"
            ><code class="language-c">// example in Pseudo C
int i = 0;
loop_start:
 if (i < 10) {
 printf("%d\n", i);
 i++;
 goto loop_start;
 }
printf("done!n");</code></pre>
            <pre
              class="code-block"
            ><code class="language-x86asm">; can be write in ASM like this
01: 00401002 mov edi, ds:__imp__printf
02: 00401008 xor esi, esi
03: 0040100A lea ebx, [ebx+0]
04: 00401010 loc_401010:
05: 00401010 push esi
06: 00401011 push offset Format ; "%d\n"
07: 00401016 call edi ; __imp__printf
08: 00401018 inc esi
09: 00401019 add esp, 8
10: 0040101C cmp esi, 0Ah
11: 0040101F jl short loc_401010
12: 00401021 push offset aDone ; "done!\n"
13: 00401026 call edi ; __imp__printf
14: 00401028 add esp, 4</code></pre>
          </section> -->
      </article>
      <div id="modal" class="modal">
        <span id="closeModal" class="close-btn">&times;</span>
      </div>
    </main>
    <script src="../../../assets/app.obf.js" defer></script>
  </body>
</html>
